/* automatically generated by rust-bindgen 0.72.0 */

pub const LERC_VERSION_MAJOR: u32 = 4;
pub const LERC_VERSION_MINOR: u32 = 0;
pub const LERC_VERSION_PATCH: u32 = 0;
#[doc = "! Added in version 4.0:\n!\n! - 1) better support 3D and 4D data, allow for lossy encoding even if a noData value is used\n! - 2) better lossless compression for float and double (pass maxZError = 0)\n! - 3) allow to pass integer > 32 bit as double (Lerc detects it is all integer and uses that)\n! - 4) renamed nDim to nDepth (without changing the function signatures)\n!\n! More on 1). In version 3.0, for 2D images, the 2D valid / invalid byte masks represent invalid pixels.\n! For more than 1 band, different masks per band can be used. No change to that.\n! For nDepth > 1, or an array of values per pixel, there is the special case of a mix of valid and invalid values\n! at the same pixel. The 2D mask cannot cover this case.\n! We have added 4 new functions to version 4.0 to cover this case, see below. If you don't encounter this\n! \"mixed case\", you can continue using the same API functions as in version 3.0.\n! If you should encounter a Lerc blob that has this mix, both the regular lerc_decode() and\n! lerc_getDataRanges() functions will fail with \"ErrCode::HasNoData\".\n! In that case, you need to call the new lerc_decode_4D() function.\n!\n! More on 2). Better lossless compression for float and double is enabled for all API functions.\n! For 1) and 3) you have to call the new \"..._4D()\" functions, see further below."]
pub type lerc_status = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = "! The image or mask of valid pixels is optional. Nullptr means all pixels are valid.\n! If not all pixels are valid, set invalid pixel bytes to 0, valid pixel bytes to 1.\n! Size of the valid / invalid pixel image is (nCols * nRows * nMasks)."]
    pub fn lerc_computeCompressedSize(
        pData: *const ::std::os::raw::c_void,
        dataType: ::std::os::raw::c_uint,
        nDepth: ::std::os::raw::c_int,
        nCols: ::std::os::raw::c_int,
        nRows: ::std::os::raw::c_int,
        nBands: ::std::os::raw::c_int,
        nMasks: ::std::os::raw::c_int,
        pValidBytes: *const ::std::os::raw::c_uchar,
        maxZErr: f64,
        numBytes: *mut ::std::os::raw::c_uint,
    ) -> lerc_status;
}
unsafe extern "C" {
    #[doc = "! Encode the input data into a compressed Lerc blob."]
    pub fn lerc_encode(
        pData: *const ::std::os::raw::c_void,
        dataType: ::std::os::raw::c_uint,
        nDepth: ::std::os::raw::c_int,
        nCols: ::std::os::raw::c_int,
        nRows: ::std::os::raw::c_int,
        nBands: ::std::os::raw::c_int,
        nMasks: ::std::os::raw::c_int,
        pValidBytes: *const ::std::os::raw::c_uchar,
        maxZErr: f64,
        pOutBuffer: *mut ::std::os::raw::c_uchar,
        outBufferSize: ::std::os::raw::c_uint,
        nBytesWritten: *mut ::std::os::raw::c_uint,
    ) -> lerc_status;
}
unsafe extern "C" {
    #[doc = "! Use the 2 functions below to encode to an older codec version"]
    pub fn lerc_computeCompressedSizeForVersion(
        pData: *const ::std::os::raw::c_void,
        codecVersion: ::std::os::raw::c_int,
        dataType: ::std::os::raw::c_uint,
        nDepth: ::std::os::raw::c_int,
        nCols: ::std::os::raw::c_int,
        nRows: ::std::os::raw::c_int,
        nBands: ::std::os::raw::c_int,
        nMasks: ::std::os::raw::c_int,
        pValidBytes: *const ::std::os::raw::c_uchar,
        maxZErr: f64,
        numBytes: *mut ::std::os::raw::c_uint,
    ) -> lerc_status;
}
unsafe extern "C" {
    pub fn lerc_encodeForVersion(
        pData: *const ::std::os::raw::c_void,
        codecVersion: ::std::os::raw::c_int,
        dataType: ::std::os::raw::c_uint,
        nDepth: ::std::os::raw::c_int,
        nCols: ::std::os::raw::c_int,
        nRows: ::std::os::raw::c_int,
        nBands: ::std::os::raw::c_int,
        nMasks: ::std::os::raw::c_int,
        pValidBytes: *const ::std::os::raw::c_uchar,
        maxZErr: f64,
        pOutBuffer: *mut ::std::os::raw::c_uchar,
        outBufferSize: ::std::os::raw::c_uint,
        nBytesWritten: *mut ::std::os::raw::c_uint,
    ) -> lerc_status;
}
unsafe extern "C" {
    pub fn lerc_getBlobInfo(
        pLercBlob: *const ::std::os::raw::c_uchar,
        blobSize: ::std::os::raw::c_uint,
        infoArray: *mut ::std::os::raw::c_uint,
        dataRangeArray: *mut f64,
        infoArraySize: ::std::os::raw::c_int,
        dataRangeArraySize: ::std::os::raw::c_int,
    ) -> lerc_status;
}
unsafe extern "C" {
    pub fn lerc_getDataRanges(
        pLercBlob: *const ::std::os::raw::c_uchar,
        blobSize: ::std::os::raw::c_uint,
        nDepth: ::std::os::raw::c_int,
        nBands: ::std::os::raw::c_int,
        pMins: *mut f64,
        pMaxs: *mut f64,
    ) -> lerc_status;
}
unsafe extern "C" {
    pub fn lerc_decode(
        pLercBlob: *const ::std::os::raw::c_uchar,
        blobSize: ::std::os::raw::c_uint,
        nMasks: ::std::os::raw::c_int,
        pValidBytes: *mut ::std::os::raw::c_uchar,
        nDepth: ::std::os::raw::c_int,
        nCols: ::std::os::raw::c_int,
        nRows: ::std::os::raw::c_int,
        nBands: ::std::os::raw::c_int,
        dataType: ::std::os::raw::c_uint,
        pData: *mut ::std::os::raw::c_void,
    ) -> lerc_status;
}
unsafe extern "C" {
    #[doc = "! Same as above, but decode into double array independent of compressed data type.\n! Wasteful in memory, but convenient if a caller from Python or C# does not want to deal with\n! data type conversion, templating, or casting.\n! Should this api be extended to new data types that don't fit into a double such as int64,\n! then this function will fail for such compressed data types."]
    pub fn lerc_decodeToDouble(
        pLercBlob: *const ::std::os::raw::c_uchar,
        blobSize: ::std::os::raw::c_uint,
        nMasks: ::std::os::raw::c_int,
        pValidBytes: *mut ::std::os::raw::c_uchar,
        nDepth: ::std::os::raw::c_int,
        nCols: ::std::os::raw::c_int,
        nRows: ::std::os::raw::c_int,
        nBands: ::std::os::raw::c_int,
        pData: *mut f64,
    ) -> lerc_status;
}
unsafe extern "C" {
    #[doc = "! Encode functions:\n!\n! If you don't use a noData value, are fine with the byte masks, just pass nullptr for the last 2 arguments.\n!\n! If you do have noData values at pixels that are marked as valid pixels by the byte mask,\n! pass 2 arrays of size nBands each, one value per band.\n! In pUsesNoData array, for each band, pass 1 for noData value is used, 0 if not.\n! In noDataValues array, for each band, pass the noData value if there is one."]
    pub fn lerc_computeCompressedSize_4D(
        pData: *const ::std::os::raw::c_void,
        dataType: ::std::os::raw::c_uint,
        nDepth: ::std::os::raw::c_int,
        nCols: ::std::os::raw::c_int,
        nRows: ::std::os::raw::c_int,
        nBands: ::std::os::raw::c_int,
        nMasks: ::std::os::raw::c_int,
        pValidBytes: *const ::std::os::raw::c_uchar,
        maxZErr: f64,
        numBytes: *mut ::std::os::raw::c_uint,
        pUsesNoData: *const ::std::os::raw::c_uchar,
        noDataValues: *const f64,
    ) -> lerc_status;
}
unsafe extern "C" {
    pub fn lerc_encode_4D(
        pData: *const ::std::os::raw::c_void,
        dataType: ::std::os::raw::c_uint,
        nDepth: ::std::os::raw::c_int,
        nCols: ::std::os::raw::c_int,
        nRows: ::std::os::raw::c_int,
        nBands: ::std::os::raw::c_int,
        nMasks: ::std::os::raw::c_int,
        pValidBytes: *const ::std::os::raw::c_uchar,
        maxZErr: f64,
        pOutBuffer: *mut ::std::os::raw::c_uchar,
        outBufferSize: ::std::os::raw::c_uint,
        nBytesWritten: *mut ::std::os::raw::c_uint,
        pUsesNoData: *const ::std::os::raw::c_uchar,
        noDataValues: *const f64,
    ) -> lerc_status;
}
unsafe extern "C" {
    pub fn lerc_decode_4D(
        pLercBlob: *const ::std::os::raw::c_uchar,
        blobSize: ::std::os::raw::c_uint,
        nMasks: ::std::os::raw::c_int,
        pValidBytes: *mut ::std::os::raw::c_uchar,
        nDepth: ::std::os::raw::c_int,
        nCols: ::std::os::raw::c_int,
        nRows: ::std::os::raw::c_int,
        nBands: ::std::os::raw::c_int,
        dataType: ::std::os::raw::c_uint,
        pData: *mut ::std::os::raw::c_void,
        pUsesNoData: *mut ::std::os::raw::c_uchar,
        noDataValues: *mut f64,
    ) -> lerc_status;
}
unsafe extern "C" {
    pub fn lerc_decodeToDouble_4D(
        pLercBlob: *const ::std::os::raw::c_uchar,
        blobSize: ::std::os::raw::c_uint,
        nMasks: ::std::os::raw::c_int,
        pValidBytes: *mut ::std::os::raw::c_uchar,
        nDepth: ::std::os::raw::c_int,
        nCols: ::std::os::raw::c_int,
        nRows: ::std::os::raw::c_int,
        nBands: ::std::os::raw::c_int,
        pData: *mut f64,
        pUsesNoData: *mut ::std::os::raw::c_uchar,
        noDataValues: *mut f64,
    ) -> lerc_status;
}
